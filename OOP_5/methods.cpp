#include "methods.h"
#include "Header.h"
#include <time.h>

void first_methods()
{
	std::cout << "____________________________________________\n" << std::endl;


	Common_sec* first = new Specific_incorrect();
	std::cout << "////////////////////////////////////////" << std::endl;
	Common* second = new Specific_correct();
	std::cout << "////////////////////////////////////////" << std::endl;
	/*
	В данном случае вызывается метод, который в перовм случае перекрывается базовым классом,
	а во втором случае метод переопределяется методом наследуемого класса
	*/
	first->print();
	std::cout << "////////////////////////////////////////" << std::endl;
	second->print();
	std::cout << "////////////////////////////////////////" << std::endl;
	delete first;
	std::cout << "////////////////////////////////////////" << std::endl;
	delete second;
	std::cout << "////////////////////////////////////////" << std::endl;
	/*
	При удаление указателей на объекты, в первом случае вызовится перекрываемый деструктор базового
	класса, а во втором случае вызовится сначала деструктор базового класса, затем деструктор
	наследуемого класса
	*/
}
void second_methods()
{
	std::cout << "____________________________________________\n" << std::endl;


	Specific_incorrect* first = new Specific_incorrect();
	std::cout << "////////////////////////////////////////" << std::endl;
	Specific_correct* second = new Specific_correct();
	std::cout << "////////////////////////////////////////" << std::endl;
	
	first->method1();
	std::cout << "////////////////////////////////////////" << std::endl;
	second->method1();
	std::cout << "****************************************" << std::endl;
	Common_sec* third(first);
	////////////////////////////////////////////////////////////////////
	third->method2();
	std::cout << "////////////////////////////////////////" << std::endl;
	Common* fourth(second);
	////////////////////////////////////////////////////////////////////
	fourth->method2();
	std::cout << "////////////////////////////////////////" << std::endl;
	delete first;
	std::cout << "////////////////////////////////////////" << std::endl;
	delete second;
	std::cout << "////////////////////////////////////////" << std::endl;
}
void third_methods()
{
	std::cout << "____________________________________________\n" << std::endl;
	srand(time(NULL));
	Common* order[5];
	for (int x = 0; x < 5; x++)
	{
		if (rand() % 2 == 0)
		{
			order[x] = new Common;
		}
		else if (rand() % 2 == 1)
		{
			order[x] = new Specific_sec;
		}
		else order[x] = new Specific_thr;

	}

	//Небезопасное приведение типов 
	/*
	Т.к.на входе был указатель Common, на выходе появился указатель Specific_sec
	и если бы мы не сделали проверку, то вышла бы ошибка. Потому что мы не
	можем быть уверены в том, что данный указатель ссылается на объект нам нужный.
	*/
	for (int z = 0; z < 5; z++)
	{
		if (order[z]->classname() == "Specific_sec")
		{
			static_cast<Specific_sec*> (order[z])->someMethod();
		}
		if (order[z]->isA("Specific_sec"))
		{
			((Specific_sec*)order[z])->method1();
		}
	}

	/*
	В данном случае мы исопльзуем динамическое преобразование, которое яв-ся 
	безопасным. Оно возращает нам тот же самый адресс объекта, если он удо-
	влетворяет нас по типу объекта, с преобразованным указателем.
	*/
	for (int s = 0; s < 5; s++)
	{
		Specific_thr* c{ dynamic_cast<Specific_thr*>(order[s]) };
		if (c)
			((Specific_thr*)order[s])->someMethod();
		else std::cout << "Object is not Specific_thr" << std::endl;
	}
	/*
	Приведение типов в узком смысле	ООП нужно тогда, когда мы объекты
	классов-потомков храним в переменных классовпредков, но при этом нам нужно 
	проверить возможность вызова и вызвать какой-то метод,	который специфичен
	только для некоторых из классов, которые мы единообразно храним.
	*/
}

void fourth_method()
{
	Object objO;
	Object* objpO = new Object();

	
	in1(objO);
	in2(&objO);
	in3(objO);

	in1(*objpO);
	in2(objpO);
	in3(*objpO);

	/*
	При передаче объекта в первую функцию компилятор создаёт копию
	исходного объекта с помощью конструктора копирования.Это
	означает, во-первых, дополнительные потери времени и памяти при
	вызове этой функции, а во-вторых, что любые изменения объекта
	внутри функции никак не повлияют на переданный в неё объект,
	потому что будут выполняться именно с копией. При выходе из
	первой функции созданная копия будет уничтожена. При передаче
	объекта во вторую и третью функции он не копируется, и функция
	работает с исходным объектом (и может его изменить), а при
	выходе из функции, соответственно, ничего не удаляется,
	раз не создавалось.
	*/

	Object o1;
	o1 = out1();
	/*
	Cначала создаст объект o1, потом внутри функции out1 создаст 
	локальный объект, потом конструктором копирования создаст 
	временный объект для возврата результата из функции, потом
	уничтожит локальный объект, потом побитово скопирует результат
	в o1, потом уничтожит этот возвращённый из функции временный объект
	*/
	Object o2;
	o2 = out2();
	/*
	Внутри функции out2 он создаст динамический объект, потом 
	конструктором копирования создаст временный объект для 
	возврата результата из функции, потом побитово скопирует результат
	в o2, потом уничтожит этот возвращённый из функции временный 
	объект. А созданный объект остается висеть где-то в памяти 
	*/
	Object* o3 = out3();
	/*
	Внутри неё статически создаётся локальный объект.В переменную o3
	складывается адрес локального объекта: объекта, который уже уничтожен.
	*/
	Object* o4 = out4();
	/*
	После захода внутрь функции мы увидим, как создаётся динамический 
	объект и его адрес из функции возвращается и помещается в переменную o4.
	Функция нам вместе с адресом объекта o4 вручила поручение о его 
	своевременном уничтожении, когда он будет больше не нужен, и мы об 
	этом не должны забывать
	*/
	Object &o5 = out5();
	/*
	Очень похожая ситуация с функцией номер 3: внутри неё статически 
	создаётся локальный объект, прямо перед выходом из функции этот локальный
	объект уничтожается, но ему успевает назначиться новое имя o5
	*/
	Object& o6 = out6();
	/*
	Этот вариант похож на четвёртый вариант, но проблема с удалением 
	объекта, ответственность за который повисла на нас, стала гораздо 
	тяжелее: ссылки не удаляют те объекты, на которые они указывают.
	Удалить такой объект можно: delete &o6.
	*/

}
void in1(Object obj) {
	std::cout << "inside_function_in1_\n" << std::endl;
}
void in2(Object* obj) {
	std::cout << "inside_function_in2_\n" << std::endl;
}
void in3(Object &obj) {
	std::cout << "inside_function_in3_\n" << std::endl;
}
Object out1()
{
	Object o;
	return o;
}
Object out2()
{
	Object* o = new Object();
	return *o;
}
Object* out3()
{
	Object o;
	return &o;
}	
Object* out4()
{
	Object* o = new Object();
	return o;
} 
Object& out5()
{
	Object o;
	return o;
}
Object& out6()
{
	Object *o = new Object();
	return *o;
}