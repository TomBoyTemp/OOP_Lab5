#include <iostream>
#include <memory>
#include "Header.h"
#include "methods.h"


void pass_object(std::unique_ptr<Object> p)
{
	p->dump();
}
std::shared_ptr<Object> pass_object(std::shared_ptr<Object> p)
{
	p->dump();
	return p;
}
int main()
{
	fourth_method();
	/*
	Использовать unique_ptr для хранения конкретного объекта Object нужно для
	того, чтобы не только технически (постараться) обеспечить отсутствие 
	«нелицензионных указателей» на этот объект, но для того, чтобы 
	подчеркнуть: «тот кусок кода, что держит этот unique_ptr, является владельцем
	объекта Object и отвечает за его время жизни»
	*/
	{
	std::unique_ptr<Object> p = std::make_unique<Object>();
	pass_object(move(p));
	}
	/*
	Эта добавка move() декларирует: теперь ответственность за время жизни Object
	переходит туда, в функцию pass_object(). У нас появляется два умных указателя 
	– один в основной программе, а другой в функции pass_object(), но при этом 
	указатель на один единственный существующий Object в каждый момент времени 
	будет только в одном из них.
	*/
	
	/*
	Другой умный указатель shared_ptr предлагает другое решение. Он говорит: 
	«Давайте так: кто последний останется, тот и удалит объект». Этот подход 
	позволяет множеству существующих shared_ptr хранить указатель на один и 
	тот же объект вместе с подсчётом количества таких shared_ptr. Как только
	появляется новый shared_ptr, хранящий ссылку на всё тот же объект, 
	счётчик ссылок для этого указателя увеличивается на единицу, а как
	очередной shared_ptr удаляется, счётчик ссылок уменьшается. Как только 
	он достигнет нуля – объект будет удалён.
	*/
	{
		std::shared_ptr<Object> p = std::make_shared<Object>();
		p = pass_object(p);
		std::shared_ptr<Object> p2 = p;
		p2->dump();
	}
	/*
	Как видим, с shared_ptr никаких проблем с передачей его в функцию и 
	возврата из неё нет, как нет их и с присваиванием в другую переменную. 
	Счётчик ссылок автоматически увеличивается и уменьшается при любом таком
	присвоении и удалении очередного локального умного указателя соответственно.
	*/
	first_methods();
	return 0;
}

